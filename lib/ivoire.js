// Generated by CoffeeScript 1.9.3

/*

Ivoire Core
===========

A pseudo-random number generator, rare, powerful, and extensible.

Ivoire is a pseudo-random number generator, powered by the Mersenne
Twister. Ivoire provides the building blocks for generating deterministic
random sequences. Deterministic, or pseudo-random sequences appear random,
but are repeatable from the same seed.

Ivoire is designed to be extensible, and has a constellation of plugins for
various purposes.

The core of Ivoire (and some of its plugins) is based roughly on the core of
[chancejs](http://chancejs.com/).
 */

(function() {
  var Ivoire, MAX_INT, MIN_INT, MersenneTwister;

  MersenneTwister = require('mersenne-twister');

  MAX_INT = 9007199254740992;

  MIN_INT = -MAX_INT;

  Ivoire = (function() {
    function Ivoire(seed) {
      this.seed = seed;
      this.twister = new MersenneTwister(seed);
    }


    /*
    If the test is true, throw a RangeError with the given error message.
     */

    Ivoire.prototype.panic_if = function(test, errorMessage) {
      if (test) {
        throw new RangeError("Ivoire: " + errorMessage);
      }
    };


    /*
    Return a new Ivoire instance seeded from the next random number in sequence.
     */

    Ivoire.prototype.subgen = function() {
      return new Ivoire(this.twister.random_int());
    };


    /*
    Return a random float on the [0, 1) real interval (same as `Math.random`).
     */

    Ivoire.prototype.random = function() {
      return this.twister.random();
    };


    /*
    Return a random integer on the provided interval.
    
    NOTE the max and min are INCLUDED in the range. So:
    ring.integer({min: 1, max: 3});
    would return either 1, 2, or 3.
    
    @param {Object} [options={}] can specify a min and/or max
    @returns {Number} a single random integer number
    @throws {RangeError} min cannot be greater than max
     */

    Ivoire.prototype.integer = function(options) {
      var max, min;
      min = options && options.min ? options.min : MIN_INT;
      max = options && options.max ? options.max : MAX_INT;
      this.panic_if(min > max, "Min cannot be greater than Max.");
      return Math.floor(this.random() * (max - min + 1) + min);
    };


    /*
    Return a random natural integer on the provided interval.
    
    NOTE the max and min are INCLUDED in the range. So:
    ring.natural({min: 1, max: 3});
    would return either 1, 2, or 3.
    
    If no interval is provided, use {min: 0, max: MAX_INT}
    
    @param {Object} [options={}] can specify a min and/or max
    @returns {Number} a single random integer number
    @throws {RangeError} min cannot be greater than max
     */

    Ivoire.prototype.natural = function(options) {
      if (!options.min) {
        options.min = 0;
      }
      this.panic_if(options.min < 0, "Min cannot be less than zero.");
      return this.integer(options);
    };


    /*
    Return a random element (or random elements) from the provided array.
    
    @param {Array} [arr] the array to pick from
    @returns {Object} a single item from the array
     */

    Ivoire.prototype.pick = function(arr) {
      this.panic_if(arr.length === 0, "Cannot pick() from an empty array");
      return arr[this.natural({
        max: arr.length - 1
      })];
    };


    /*
    Return random elements from the provided array.
    
    @param {Array} [arr] the array to pick from
    @param {Number} [count=1] how many items to pick from the array
    @returns {Array} a slice of item from the array
     */

    Ivoire.prototype.pick_some = function(arr, count) {
      this.panic_if(arr.length === 0, "Cannot pick_some() from an empty array");
      return this.shuffle(arr).slice(0, count);
    };


    /*
    Return a randomly shuffled copy of the provided array.
    
    @param {Array} [arr] the array to shuffle
    @returns {Array} a shuffled copy of the array
     */

    Ivoire.prototype.shuffle = function(arr) {
      var i, j, k, length, new_array, old_array, ref;
      old_array = arr.slice(0);
      new_array = [];
      j = 0;
      length = Number(old_array.length);
      for (i = k = 0, ref = length; 0 <= ref ? k <= ref : k >= ref; i = 0 <= ref ? ++k : --k) {
        j = this.natural({
          max: old_array.length - 1
        });
        new_array[i] = old_array[j];
        old_array.splice(j, 1);
      }
      return new_array;
    };

    return Ivoire;

  })();

  module.exports = Ivoire;

}).call(this);
